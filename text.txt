#include "so.h"
#include <algorithm> 
#include<stdlib.h> 
#include<stdio.h> 
#include <vector>
#include "omp.h"

// eg how to use partition (return pivot)
int highestPowerof2(int n) 
{ 
    int res = 0; 
    for (int i=n; i>=1; i--) 
    { 
        // If i is a power of 2 
        if ((i & (i-1)) == 0) 
        { 
            res = i; 
            break; 
        } 
    } 
    return res; 
} 

data_t median(std::vector <data_t> &array, int n) {
    nth_element(array.begin(), array.begin() + n/2, array.end());
    return array[n/2];
}

void psort(int n, data_t* data) {
    if(n < 2) {
        return;
    }
    int n_threads = highestPowerof2(std::min(n,omp_get_max_threads()));
    if(n_threads < 2) {
        std::sort(data + 0, data + n);
        return;
    }

    std::vector <int> previousBound(n_threads + 1);
    std::vector <int> currentBound(n_threads + 1);
    std::vector <int> temp(n_threads + 1);
    // initialize with a default partition 
    previousBound[0] = 0;
    data_t pivot = *std::next(data + 0, std::distance(data + 0,data + n)/2);
    previousBound[1] = std::distance(
        data + 0,
        std::partition(data + 0, data + n,  [pivot](const data_t& em){ return em < pivot; })
    );
    previousBound[2] = n;
    int size = 10000;
    for (int noSegment = 2; noSegment < n_threads ; noSegment*=2) {
        currentBound[0] = 0;
        #pragma omp parallel for 
        for(int i = 0; i < noSegment; i++) {
            int range = previousBound[i+1] - previousBound[i];
            if(range > size*5) {
                std::vector <data_t> sample(size);
                // malloc(sizeof(data_t)*10)
                for(int j = 0; j <size; j+=1) {
                    sample[j] = data[previousBound[i]+j*5];      
                    // printf("sample index %d \n", previousBound[i]+j*5);             
                }
                nth_element(sample.begin(), sample.begin() + size/2, sample.end());
                pivot = sample[size/2];
            } else {
                pivot = *std::next(data + 0, std::distance(data + previousBound[i], data + previousBound[i+1])/2);
            }
            
            currentBound[i*2 +1] = std::distance(
                data + 0,
                std::partition (data + previousBound[i], data + previousBound[i+1],  [pivot](const data_t& em){ return em < pivot; }) 
            );
            currentBound[i*2 + 2] = previousBound[i+1];
        }
        previousBound = currentBound;
        currentBound = temp;
    }

    #pragma omp parallel for 
    for (int segment = 0; segment < n_threads; ++segment) {
        // printf("bound %d\n", previousBound[segment]);
        std::sort(data + previousBound[segment], data + previousBound[segment + 1]);
    }

}
